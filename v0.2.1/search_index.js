var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API","title":"API","text":"@concrete","category":"page"},{"location":"api/#ConcreteStructs.@concrete","page":"API","title":"ConcreteStructs.@concrete","text":"@concrete struct\n@concrete mutable struct\n@concrete terse struct\n@concrete terse mutable struct\n\nThe @concrete macro makes non-concrete structs concrete, saving the boilerplate of making type parameters. The terse keyword causes the types to show without their parameters while in :compact => true mode of an IOContext.\n\nExamples\n\njulia> using ConcreteStructs\n\njulia> @concrete struct AB\n           a\n           b\n       end\n\njulia> ab = AB(\"hi\", 1+im)\nAB{String,Complex{Int64}}(\"hi\", 1 + 1im)\n\njulia> @concrete terse mutable struct CDE{D} <: Number\n            d::D\n            c\n            e::Symbol\n        end\n\njulia> cde = CDE(1f0, (1,2.0), :yo)\nCDE(1.0f0, (1, 2.0), :yo)\n\njulia> typeof(cde)\nCDE{Float32,Tuple{Int64,Float64}}\n\njulia> @concrete terse struct FGH{T,N,G<:AbstractArray{T,N}} <: AbstractArray{T,N}\n           f\n           g::G\n           h::T\n       end\n\njulia> Base.size(x::FGH) = size(x.g); Base.getindex(x::FGH, i...) = getindex(x.g[i...])\n\njulia> fgh = FGH(nothing, [1,2,3], 4)\n3-element FGH:\n 1\n 2\n 3\n\njulia> typeof(fgh)\nFGH{Int64,1,Array{Int64,1},Nothing}\n\n\n\n\n\n","category":"macro"},{"location":"walkthrough/#Walkthrough","page":"Walkthrough","title":"Walkthrough","text":"","category":"section"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"The @concrete macro can be tacked onto any struct definition that isn't already concretely-typed. That's kinda all there is to it, but let's walk through some examples anyway to get a feel for it.","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"In this example, no type parameters are given, so they will be filled in automatically:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"@concrete struct Whatever\n    a\n    b\nend","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"julia> complex_whatever = Whatever(1+im, \"It's pretty complex\")\nWhatever{Complex{Int64},String}(1 + 1im, \"It's pretty complex\")","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"But maybe we don't want to show the type parameters, since we never cared much about them in the first place. If we want our struct to print a little more succintly, we can add the terse keyword. Now it will print as if we never added the @concrete macro.","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"@concrete terse struct PrettierWhatever\n    a\n    b\nend","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"julia> pretty_whatever = PrettierWhatever(1+im, \"It's still pretty complex\")\nPrettierWhatever(1 + 1im, \"It's still pretty complex\")","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"The full type information is still available for inspection with the typeof function, though.","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"julia> typeof(pretty_whatever)\nPrettierWhatever{Complex{Int64},String}","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"More complicated type parameterizations are possible as well. Take this example of an array with two metadata fields attached. The type parameters for the array field are provided but the name field's type is left open. The @concrete macro will respect the given type parameters and concretely parameterize the name field.","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"@concrete struct MetaArray{T,N,A<:AbstractArray{T,N}} <: AbstractArray{T,N}\n    array::A\n    name\nend\n\nBase.size(x::MetaArray) = size(x.array)\n\nBase.getindex(x::MetaArray, i...) = getindex(x.array[i...])","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"julia> abed = MetaArray([8,10,2,5], \"Abed\")\n4-element MetaArray{Int64,1,Array{Int64,1},String}:\n  8\n 10\n  2\n  5","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"We can also have type parameters that don't correspond to any field. In this example, the BananaStand type is parameterized by the boolean value has_money. ","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"@concrete terse mutable struct BananaStand{has_money}\n    employees\n    manager\nend","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"In this case, the constructor must be given with the has_money parameter, just like it would need to be if we weren't using the @concrete macro. Since the terse keyword was give, the type will print exactly as it's specified: with the has_money parameterization but no field parameterizations.","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"julia> the_banana_stand = BananaStand{true}([\"Maeby\", \"Annyong\"], \"George Michael\")\nBananaStand{true}([\"Maeby\", \"Annyong\"], \"George Michael\")\n\njulia> typeof(the_banana_stand)\nBananaStand{true,Array{String,1},String}","category":"page"},{"location":"#ConcreteStructs.jl","page":"Home","title":"ConcreteStructs.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ConcreteStructs exports the macro @concrete that will add type parameters to your struct for any field where type parameters arenâ€™t given.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Simply add the @concrete macro before any valid struct definition and it should automagically make all of your non-type-annotated fields type-annotated. If you don't like the verbose type printing ","category":"page"}]
}
